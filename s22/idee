pour STP :


typedef struct Switch{
    MACAddress mac;
    int nbport;
    int priorite;
    PortState port_states[MAX_PORTS];
    BPDU bpdus // BPDU de switch
} Switch;

////// PARTIE 4 

typedef struct {
    MACAddress root_id;
    uint32_t cost;
    MACAddress transmeter_id;
} BPDU;

typedef enum {
    INACTIF,
    RACINE,
    DESIGNATED
} PortState;


Pour transfer bpdu : 
while(change != O)
{
  
    foreach switch 
    {
       --> change = 0
       foreach voisin de 
       {
            envoyerBPDU à chaques voisin de switch 
            if envoyerBPDU a fait un changement , change++
       }    
    }      
}

envoi de BPDU à une destination et retourne 
si bpdu de destination est moins bien que bpdu de switch source
{
    //changer bpdu 
    bpdu de destination = bpdu de source 
} 
sinon 

il faut completer le code avec la mise à jour des états des ports dans le tableau PortState de switch sachant que dans ce tableau , le port 1 du switch est assimilé au PortState[1] et ainsi de suite pour chacun des port


//////// idee pour 
///////

void initBPDU(BPDU *bpdu, MACAddress root_id, uint32_t cost, MACAddress transmitting_id) {
    bpdu->root_id = root_id;
    bpdu->cost = cost;
    bpdu->transmitting_id = transmitting_id;
}

void sendBPDU(Switch *sw, int port, BPDU bpdu) {
    sw->bpdus[port] = bpdu;
    printf("Sending BPDU on port %d from switch: ", port);
    printMACAddress(sw->mac);
    printf("BPDU root ID: ");
    printMACAddress(bpdu.root_id);
    printf("Cost: %d\n", bpdu.cost);
    printf("Transmitting ID: ");
    printMACAddress(bpdu.transmitting_id);
    printf("\n");
}

void receiveBPDU(Switch *sw, int port, BPDU bpdu) {
    printf("Receiving BPDU on port %d at switch: ", port);
    printMACAddress(sw->mac);
    printf("BPDU root ID: ");
    printMACAddress(bpdu.root_id);
    printf("Cost: %d\n", bpdu.cost);
    printf("Transmitting ID: ");
    printMACAddress(bpdu.transmitting_id);
    printf("\n");

    // Update the BPDU information on the port if the new BPDU is better
    if (memcmp(&bpdu, &sw->bpdus[port], sizeof(BPDU)) < 0) {
        sw->bpdus[port] = bpdu;
        printf("Updated BPDU on port %d at switch: ", port);
        printMACAddress(sw->mac);
        printf("\n");
    }
}

void initSwitch(Switch *sw, MACAddress mac, int nbport, int priorite) {
    sw->mac = mac;
    sw->nbport = nbport;
    sw->priorite = priorite;
    for (int i = 0; i < nbport; i++) {
        sw->port_states[i] = INACTIF;
    }
}

int main() {
    // Initialisation du réseau
    Reseau r;
    r.nb_equipements = 2;
    r.tab_equipements = malloc(r.nb_equipements * sizeof(Equipement));

    // Initialisation des switches
    MACAddress mac1 = {{0x01, 0x45, 0x23, 0xa6, 0xf7, 0xab}};
    MACAddress mac2 = {{0x02, 0x45, 0x23, 0xa6, 0xf7, 0xac}};
    
    Switch sw1, sw2;
    initSwitch(&sw1, mac1, 8, 1024);
    initSwitch(&sw2, mac2, 8, 2048);

    r.tab_equipements[0].type = SWITCH;
    r.tab_equipements[0].data.m_switch = sw1;

    r.tab_equipements[1].type = SWITCH;
    r.tab_equipements[1].data.m_switch = sw2;

    // Initialiser et envoyer un BPDU depuis le premier switch
    BPDU bpdu;
    initBPDU(&bpdu, mac1, 0, mac1);
    sendBPDU(&r.tab_equipements[0].data.m_switch, 0, bpdu);

    // Recevoir le BPDU sur le deuxième switch
    receiveBPDU(&r.tab_equipements[1].data.m_switch, 0, bpdu);

    // Free mémoire
    free(r.tab_equipements);

    return 0;
}